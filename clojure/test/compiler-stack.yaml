# Copyright 2023 Ingy dot Net
# This code is licensed under MIT license (See License for details)

- name: Test label / description
    # Each test block defines a set of test cases.
    # A test file usually require 1 input and 1 output field.
    # For instance parser_test.clj requires a yamlscript and a parse field.
    # A test block need not specify all fields for every test file.
  yamlscript: |
    # YAMScript code compilation input
  parse: |
    # YAML Parser events
  compose: |
    # YAML Composer tree
  resolve: |
    # Composed tree with tags resolved
  build: |
    # Read each scalar into Clojure AST forms
  expand: |
    # Expand the YS macros (defsyn)
  construct: |
    # Construct a full Clojure AST
  print: |
    # Clojure code compilation output
  TEMPLATE: true
    # 'TEMPLATE: true' is here to ignore this test block



- name: Most YAML syntax forms in one example
  yamlscript: |
    --- !yamlscript/v0
    a: 'b'
    "c": |
      d
    ? - e: >
          f
    : - {g: !h &i j}
      - [*k, [l]]
  parse: |
    "+MAP", :! "yamlscript/v0"
    "=VAL", := "a"
    "=VAL", :' "b"
    "=VAL", :$ "c"
    "=VAL", :| "d\n"
    "+SEQ"
    "+MAP"
    "=VAL", := "e"
    "=VAL", :> "f\n"
    "-MAP"
    "-SEQ"
    "+SEQ"
    "+MAP", :flow true
    "=VAL", := "g"
    "=VAL", :& "i", :! "h", := "j"
    "-MAP"
    "+SEQ", :flow true
    "=ALI", :* "k"
    "+SEQ", :flow true
    "=VAL", := "l"
    "-SEQ"
    "-SEQ"
    "-SEQ"
    "-MAP"
  compose: |
    {:! "yamlscript/v0" :% [
      {:= "a"}
      {:' "b"}
      {:$ "c"}
      {:| "d\n"}
      {:- [
        {:% [
          {:= "e"}
          {:> "f\n"} ]} ]}
      {:- [
        {:%% [
          {:= "g"}
          {:& "i", :! "h", := "j"} ]}
        {:-- [
          {:* "k"}
          {:-- [
            {:= "l"}
          ]} ]} ]} ]}



- name: Nested parse events test
  yamlscript: |
    a:
      b:
        c: d
      e: f
    g: h
  parse: |
    "+MAP"
    "=VAL", := "a"
    "+MAP"
    "=VAL", := "b"
    "+MAP"
    "=VAL", := "c"
    "=VAL", := "d"
    "-MAP"
    "=VAL", := "e"
    "=VAL", := "f"
    "-MAP"
    "=VAL", := "g"
    "=VAL", := "h"
    "-MAP"



- name: Basic function call with 2 args (test all phases)
  yamlscript: |
    --- !yamlscript/v0
    a: b c
  parse: |
    "+MAP", :! "yamlscript/v0"
    "=VAL", := "a"
    "=VAL", := "b c"
    "-MAP"
  compose: |
    {:! "yamlscript/v0", :% [
      {:= "a"} {:= "b c"} ]}
  resolve: |
    {:pairs [
      {:exprs "a"}
      {:exprs "b c"}
    ]}
  build: |
    {:pairs [
      {:Sym a}
      [{:Sym b} {:Sym c}] ]}
  expand: |
    {:do [
      [{:Sym a}
       [{:Sym b} {:Sym c}]] ]}
  construct: |
    {:List [ {:Sym a} {:Sym b} {:Sym c} ]}
  print: |
    (a b c)



- name: Dot escaping
  yamlscript: |
    --- !yamlscript/v0
    map(inc): .[2 4 6 8]
  parse: |
    "+MAP", :! "yamlscript/v0"
    "=VAL", := "map(inc)"
    "=VAL", := ".[2 4 6 8]"
    "-MAP"
  compose: |
    {:! "yamlscript/v0" :% [
      {:= "map(inc)"}
      {:= "[2 4 6 8]"} ]}
  Xprint: |
    (map inc [2 4 6 8])



- name: YS reader forms
  yamlscript: |
    --- !yamlscript/v0
    prn: .["str" \c 42 foo true false nil]
    prn: .{:a 1 :c 2 :b 3}
    prn: ."A longer string"
  build: |
    {:pairs [
     {:Sym prn}
     {:Vec
      [{:Str "str"}
       {:Char c}
       {:LNum 42}
       {:Sym foo}
       :True
       :False
       :Nil ]}
     {:Sym prn}
     {:Map
      [{:Key :a}
       {:LNum 1}
       {:Key :c}
       {:LNum 2}
       {:Key :b}
       {:LNum 3} ]}
     {:Sym prn}
     {:Str "A longer string"} ]}
  print: |
    (do
     (prn ["str" \c 42 foo true false nil])
     (prn {:a 1, :c 2, :b 3})
     (prn "A longer string"))



- name: Basic math ysexpr
  yamlscript: |
    --- !yamlscript/v0
    inc: (6 * 7)
  build: |
    {:pairs
     [{:Sym inc}
      {:List [{:Sym *} {:LNum 6} {:LNum 7}]}]}
  print: |
    (inc (* 6 7))



- name: Function call ysexpr
  yamlscript: |
    --- !yamlscript/v0
    say: str("The number is:\ " inc(41))
  build: |
    {:pairs
     [{:Sym say}
      {:List
       [{:Sym str}
        {:Str "The number is: "}
        {:List [{:Sym inc} {:LNum 41}]}]}]}
  print: |
    (say (str "The number is: " (inc 41)))



- name: def expression
  yamlscript: |
    !yamlscript/v0
    foo =: 123
  print: |
    (def foo 123)



- name: def/let expression
  yamlscript: |
    !yamlscript/v0
    foo =: 123
    defn bar(a b):
      c =: (a + b)
      .*: 2 c
    bar: 10 20
  parse: |
    "+MAP", :! "yamlscript/v0"
    "=VAL", := "foo ="
    "=VAL", := "123"
    "=VAL", := "defn bar(a b)"
    "+MAP"
    "=VAL", := "c ="
    "=VAL", := "(a + b)"
    "=VAL", := ".*"
    "=VAL", := "2 c"
    "-MAP"
    "=VAL", := "bar"
    "=VAL", := "10 20"
    "-MAP"
  compose: |
    {:! "yamlscript/v0" :% [
      {:= "foo ="}
      {:= "123"}
      {:= "defn bar(a b)"}
      {:% [
        {:= "c ="}
        {:= "(a + b)"}
        {:= "*"}
        {:= "2 c"} ]}
      {:= "bar"}
      {:= "10 20"} ]}
  resolve: |
    {:pairs [
      {:def "foo ="}
      {:exprs "123"}
      {:defn "defn bar(a b)"}
      {:pairs [
        {:let "c ="}
        {:exprs "(a + b)"}
        {:exprs "*"}
        {:exprs "2 c"} ]}
      {:exprs "bar"}
      {:exprs "10 20"} ]}
# build: |
# expand: |
# construct: |
# print: |
#   (def foo 123)
#   (defn bar [a b]
#     (let [c (+ a b)]
#       (* 2 c)))
#   bar: 10 20
#  ONLY: true
  SKIP: true



# - name: The 'if' special form
#   yamlscript: |
#     if (a > b):
#       foo(a b)
#       bar(a b)
#   print: |
#     (if (> a b) (foo a b) (bar a b))
#   SKIP: true

# - name: YAMLScript top level scalar
#   yamlscript: |
#     ; comment
#     (foo bar)
#   parse: |
#     :; comment\n(foo bar)
#   XXXprint: |
#     (foo bar)
